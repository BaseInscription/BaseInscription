const b="InscriptionCache",o="inscriptions";class w{constructor(){this.db=null}async init(){return this.db?this.db:new Promise((s,e)=>{const n=indexedDB.open(b,1);n.onerror=()=>e(n.error),n.onsuccess=()=>{this.db=n.result,s(this.db)},n.onupgradeneeded=c=>{const t=c.target.result;if(!t.objectStoreNames.contains(o)){const r=t.createObjectStore(o,{keyPath:"id"});r.createIndex("timestamp","timestamp",{unique:!1}),r.createIndex("size","size",{unique:!1})}}})}async get(s){return await this.init(),new Promise((e,n)=>{const r=this.db.transaction([o],"readonly").objectStore(o).get(s);r.onsuccess=()=>{const i=r.result;if(!i){e(null);return}Date.now()-i.timestamp>7*24*60*60*1e3?(this.delete(s),e(null)):e(i)},r.onerror=()=>n(r.error)})}async set(s,e,n,c=!1){if(c)return;await this.init();const t=new Blob([e]).size;if(t>8*1024*1024){console.log("Content too large to cache:",(t/1024/1024).toFixed(2),"MB");return}return await this.manageCacheSize(t),new Promise((r,i)=>{const u=this.db.transaction([o],"readwrite").objectStore(o),h={id:s,dataHex:e,dataType:n,timestamp:Date.now(),size:t},d=u.put(h);d.onsuccess=()=>r(),d.onerror=()=>i(d.error)})}async delete(s){return await this.init(),new Promise((e,n)=>{const r=this.db.transaction([o],"readwrite").objectStore(o).delete(s);r.onsuccess=()=>e(),r.onerror=()=>n(r.error)})}async getTotalSize(){return await this.init(),new Promise((s,e)=>{const t=this.db.transaction([o],"readonly").objectStore(o).getAll();t.onsuccess=()=>{const i=t.result.reduce((a,u)=>a+(u.size||0),0);s(i)},t.onerror=()=>e(t.error)})}async manageCacheSize(s){const e=await this.getTotalSize();if(!(e+s<=314572800))return await this.init(),new Promise((n,c)=>{const a=this.db.transaction([o],"readwrite").objectStore(o).index("timestamp").openCursor();let u=0;const h=e+s-314572800;a.onsuccess=d=>{const l=d.target.result;l&&u<h?(u+=l.value.size||0,l.delete(),l.continue()):n()},a.onerror=()=>c(a.error)})}async clear(){return await this.init(),new Promise((s,e)=>{const t=this.db.transaction([o],"readwrite").objectStore(o).clear();t.onsuccess=()=>s(),t.onerror=()=>e(t.error)})}}const S=new w;export{S as d};
