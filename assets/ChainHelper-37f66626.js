import{C as E,I as L,M as B,b as w,D as T,a as A}from"./abi-d39c13d1.js";import{G as y}from"./index-35adf578.js";import{ab as M,M as f}from"./element-plus-01463170.js";import{C as v,a as O,t as _,b as D,p as h,c as k,d as C,f as $,g as F,j as S,J as P}from"./ethers-86161a64.js";class Q{constructor(t){this.contract=new v(E,L,t)}stringToBytes32(t){return O(t)}bytes32ToString(t){return _(t).replace(/\0/g,"")}chunkData(t){const e=[];for(let n=0;n<t.length;n+=B)e.push(t.slice(n,n+B));return e}async inscribeInline(t,e){const n=D(t);return await(await this.contract.inscribeInline(n,{value:h(w)})).wait()}async inscribeData(t,e,n="",s,r,a,i){const o=this.stringToBytes32(t),c=this.chunkData(e),l=n?this.stringToBytes32(n):k;return console.log("inscribeData chunks",c.length),c.length>4?await this.handleInscribeBigData(o,c,l,s,r,a,i):await(await this.contract.inscribeData(o,c,l,{value:h(w)})).wait()}async handleInscribeBigData(t,e,n,s,r,a,i){var I;let o=null,c=0;const l=Math.ceil(e.length/4);try{o=M.service({lock:!0,text:r>0?"":`Uploading data to blockchain (${c-a}/${l-a})...Dont't refresh the website!`,background:"rgba(0, 0, 0, 0.6)"});let u=0,d=null;if(r==0){i&&i(c,l);const m=await this.contract.inscribeBigData(t,e.slice(0,4),n,e.length,{value:h(w)});c++,this._setLoadingText(o,c-a,l-a),i&&i(c,l),d=await m.wait(),console.log("handleInscribeBigData receipt",d),u=(I=d.logs.map(g=>{try{return this.contract.interface.parseLog(g)}catch{return null}}).filter(g=>g&&g.name==="Inscribe")[0])==null?void 0:I.args[0],y.markCurInscribingBigDataInscriptionId(u)}else if(c=r,this._setLoadingText(o,c-a,l-a),u=y.GetCurInscribingBigDataInscriptionId(),!u){f.error("Invalid status, please refresh website");return}console.log(`handleInscribeBigData itemId:${u}, sentTxCount:${r}`);const N=r>0?r*4:4;for(let m=N;m<e.length;m+=4){const b=e.slice(m,Math.min(m+4,e.length)),g=m;console.log(`Appending group ${Math.floor(m/4)}:`,b.length,"chunks starting at index",g);const x=await this.contract.appendBigData(u,g,b);c++,this._setLoadingText(o,c-a,l-a),i&&i(c,l),d=await x.wait(),console.log(`âœ… Appended group ${Math.floor(m/4)} successfully`)}return console.log("ðŸŽ‰ handleInscribeBigData finish"),d}catch(u){throw console.error(u),u}finally{o&&o.close()}}_setLoadingText(t,e,n){t.setText(`Uploading data to blockchain (Sent ${e}/${n})...Dont't refresh the website!`)}async inscribeBigData(t,e,n,s){const r=n?this.stringToBytes32(n):k,a=this.stringToBytes32(t);return await(await this.contract.inscribeBigData(a,e,r,s,{value:h(w)})).wait()}async appendBigData(t,e,n){return await(await this.contract.appendBigData(t,e,n)).wait()}async deployToken(t,e,n,s,r,a){if(!await this.checkBalance(a,y.InscribeEstimateGas.kDeployToken,Number(T)))return;const o=this.stringToBytes32(e);return console.log("deployToken",{name:t,symbol:e,decimals:n,mintTimes:s,amountPerMint:r,symbolBytes32:o}),await(await this.contract.deployToken(t,o,BigInt(n),BigInt(s),BigInt(r),{value:h(T)})).wait()}async mintToken(t,e){const n=this.stringToBytes32(t);return await(await this.contract.mintToken(n,{value:h(A)})).wait()}async checkBalance(t,e,n){if(window.lastCheckBalanceTime&&window.lastBalance&&Date.now()-window.lastCheckBalanceTime<6e4&&window.lastBalance>.03)return console.log("checkBalance simple return"),!0;window.lastCheckBalanceTime=Date.now();const s=await this.contract.runner.provider.getBalance(t),r=parseFloat(C(s));window.lastBalance=r,console.log(`User: ${t}, balance: ${r} ETH`);const a=await this.contract.runner.provider.send("eth_gasPrice",[]),i=BigInt(a),o=parseFloat($(i,"gwei"));console.log("Current gas price:",o,"gwei");const c=e*i,l=parseFloat(C(c))*1.5+parseFloat(n);return console.log("minEth",l),r<l?(f.error(`Insufficient balance: need at least ${l.toFixed(4)} ETH, but you have ${r.toFixed(4)} ETH.`),!1):!0}async setTokenURI(t,e){const n=this.stringToBytes32(t);return await(await this.contract.setTokenURI(n,e)).wait()}async getItem(t){const e=await this.contract.getItem(t);return{dataType:this.bytes32ToString(e.dataType),inlineData:e.inlineData,dataHolders:e.dataHolders,userData:this.bytes32ToString(e.userData),contentSize:Number(e.contentSize)}}async findFirstInlines(t){const e=t.map(n=>D(n));return await this.contract.findFirstInlines(e)}async itemIdsByOwnerAndIndexList(t,e){return await this.contract.itemIdsByOwnerAndIndexList(t,e)}async getSymbolList(t,e){return(await this.contract.getSymbolList(t,e)).map(s=>this.bytes32ToString(s))}async getTokenInfoList(t,e){const[n,s,r,a]=await this.contract.getTokenInfoList(t,e);return r.map((i,o)=>({name:s[o],symbol:this.bytes32ToString(n[o]),decimals:i.decimals,token:i.token,totalSupply:BigInt(i.amountPerMint)*BigInt(i.mintTimes),amountPerMint:i.amountPerMint.toString(),mintTimes:Number(i.mintTimes),createAt:Number(i.createAt),itemId:Number(i.itemId),minted:a[o].toString()}))}async getTokenInfoListBySymbols(t){let e=[];for(const a of t)e.push(this.stringToBytes32(a));const[n,s,r]=await this.contract.getTokenInfoListBySymbols(e);return s.map((a,i)=>({name:n[i],symbol:t[i],decimals:a.decimals,token:a.token,totalSupply:BigInt(a.amountPerMint)*BigInt(a.mintTimes),amountPerMint:a.amountPerMint.toString(),mintTimes:Number(a.mintTimes),createAt:Number(a.createAt),itemId:Number(a.itemId),minted:r[i].toString()}))}async getItemList(t,e){return(await this.contract.getItemList(t,e)).map(s=>({dataType:this.bytes32ToString(s.dataType),inlineData:s.inlineData,dataHolders:s.dataHolders,userData:this.bytes32ToString(s.userData),contentSize:Number(s.contentSize)}))}async readAddressCodes(t){return await this.contract.readAddressCodes(t)}async readData(t){return console.log("onchain readData",t),await this.contract.readData(t)}async readDataList(t){return console.log("onchain readDataList",t),await this.contract.readDataList(t)}async getSymbolCounter(){return Number(await this.contract.symbolCounter())}async validateSymbol(t){const e=this.stringToBytes32(t),[n,s]=await this.contract.validateSymbol(e);return{isValid:n,length:Number(s)}}async getItemIdCounter(){return window.lastQueryItemIdCountTime&&Date.now()-window.lastQueryItemIdCountTime<=1e4||(window.lastQueryItemIdCountTime=Date.now(),window.lastQueryItemIdCount=Number(await this.contract.itemIdCounter())),window.lastQueryItemIdCount}async ownerOf(t,e){let n=y.ownerDict[t];return(!n||!e||Date.now()-n.cacheStamp>e*1e3)&&(n={cacheStamp:Date.now(),cacheResult:await this.contract.ownerOf(t)},y.ownerDict[t]=n),n.cacheResult}async balanceOf(t){return Number(await this.contract.balanceOf(t))}async getTokenInfo(t){const e=this.stringToBytes32(t),n=await this.contract.tokenInfoDict(e);return{token:n.token,decimals:n.decimals,amountPerMint:n.amountPerMint.toString(),mintTimes:Number(n.mintTimes),totalSupply:BigInt(n.amountPerMint)*BigInt(n.mintTimes),createAt:Number(n.createAt),itemId:Number(n.itemId)}}async getTokenName(t){const e=this.stringToBytes32(t);return await this.contract.tokenNameDict(e)}async getTokenMinted(t){const e=this.stringToBytes32(t);return Number(await this.contract.tokenMintedDict(e))}async getBigDataChunkCount(t){return Number(await this.contract.bigDataChunkCountDict(t))}async tokenOfOwnerByIndex(t,e){return Number(await this.contract.tokenOfOwnerByIndex(t,e))}async totalSupply(){return Number(await this.contract.totalSupply())}static TryParseIncompleteHolderData(t){if(!t||t.length<=2||t.length>200)return null;const e=F(t),n=e.slice(11,43),s=e.slice(44,76),r=S(n),a=S(s);return{curChunkCount:r,totalChunkCount:a,desc:`Incomplete chunks: ${r}/${a}`}}static GetInscribeFileFee(){return w}}const z={kIsMainnet:!1,getProvider:function(){const p=y.GetRPCUrl();return new P(p)}};export{z as C,Q as I};
