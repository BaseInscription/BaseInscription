var mt=Object.defineProperty;var ft=(i,t,e)=>t in i?mt(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var W=(i,t,e)=>(ft(i,typeof t!="symbol"?t+"":t,e),e),Z=(i,t,e)=>{if(!t.has(i))throw TypeError("Cannot "+e)};var o=(i,t,e)=>(Z(i,t,"read from private field"),e?e.call(i):t.get(i)),b=(i,t,e)=>{if(t.has(i))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(i):t.set(i,e)},H=(i,t,e,n)=>(Z(i,t,"write to private field"),n?n.call(i,e):t.set(i,e),e);var h=(i,t,e)=>(Z(i,t,"access private method"),e);import{C as wt,I as yt,M as it,b as M,D as st,a as bt}from"./abi-d39c13d1.js";import{aC as It,a7 as pt,W as S,ab as D,au as et,at as Bt,aJ as q,g as nt,bz as J,bH as at,a1 as j,a5 as Tt,aj as lt,ap as St,bq as rt,bP as Dt,G as U,bN as ot,ad as Nt}from"./index-cfd736bd.js";const vt=BigInt(-1),f=BigInt(0),F=BigInt(1),Ct=BigInt(5),k={};let A="0000";for(;A.length<80;)A+=A;function C(i){let t=A;for(;t.length<i;)t+=t;return BigInt("1"+t.substring(0,i))}function _(i,t,e){const n=BigInt(t.width);if(t.signed){const s=F<<n-F;D(e==null||i>=-s&&i<s,"overflow","NUMERIC_FAULT",{operation:e,fault:"overflow",value:i}),i>f?i=J(at(i,n),n):i=-J(at(-i,n),n)}else{const s=F<<n;D(e==null||i>=0&&i<s,"overflow","NUMERIC_FAULT",{operation:e,fault:"overflow",value:i}),i=(i%s+s)%s&s-F}return i}function K(i){typeof i=="number"&&(i=`fixed128x${i}`);let t=!0,e=128,n=18;if(typeof i=="string"){if(i!=="fixed")if(i==="ufixed")t=!1;else{const r=i.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);S(r,"invalid fixed format","format",i),t=r[1]!=="u",e=parseInt(r[2]),n=parseInt(r[3])}}else if(i){const r=i,a=(c,u,d)=>r[c]==null?d:(S(typeof r[c]===u,"invalid fixed format ("+c+" not "+u+")","format."+c,r[c]),r[c]);t=a("signed","boolean",t),e=a("width","number",e),n=a("decimals","number",n)}S(e%8===0,"invalid FixedNumber width (not byte aligned)","format.width",e),S(n<=80,"invalid FixedNumber decimals (too large)","format.decimals",n);const s=(t?"":"u")+"fixed"+String(e)+"x"+String(n);return{signed:t,width:e,decimals:n,name:s}}function xt(i,t){let e="";i<f&&(e="-",i*=vt);let n=i.toString();if(t===0)return e+n;for(;n.length<=t;)n=A+n;const s=n.length-t;for(n=n.substring(0,s)+"."+n.substring(s);n[0]==="0"&&n[1]!==".";)n=n.substring(1);for(;n[n.length-1]==="0"&&n[n.length-2]!==".";)n=n.substring(0,n.length-1);return e+n}var w,l,g,T,x,y,B,R,X,$,Y,P,V,O,tt;const N=class N{constructor(t,e,n){b(this,T);b(this,y);b(this,R);b(this,$);b(this,P);b(this,O);W(this,"format");b(this,w,void 0);b(this,l,void 0);b(this,g,void 0);W(this,"_value");It(t,k,"FixedNumber"),H(this,l,e),H(this,w,n);const s=xt(e,n.decimals);pt(this,{format:n.name,_value:s}),H(this,g,C(n.decimals))}get signed(){return o(this,w).signed}get width(){return o(this,w).width}get decimals(){return o(this,w).decimals}get value(){return o(this,l)}addUnsafe(t){return h(this,R,X).call(this,t)}add(t){return h(this,R,X).call(this,t,"add")}subUnsafe(t){return h(this,$,Y).call(this,t)}sub(t){return h(this,$,Y).call(this,t,"sub")}mulUnsafe(t){return h(this,P,V).call(this,t)}mul(t){return h(this,P,V).call(this,t,"mul")}mulSignal(t){h(this,T,x).call(this,t);const e=o(this,l)*o(t,l);return D(e%o(this,g)===f,"precision lost during signalling mul","NUMERIC_FAULT",{operation:"mulSignal",fault:"underflow",value:this}),h(this,y,B).call(this,e/o(this,g),"mulSignal")}divUnsafe(t){return h(this,O,tt).call(this,t)}div(t){return h(this,O,tt).call(this,t,"div")}divSignal(t){D(o(t,l)!==f,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),h(this,T,x).call(this,t);const e=o(this,l)*o(this,g);return D(e%o(t,l)===f,"precision lost during signalling div","NUMERIC_FAULT",{operation:"divSignal",fault:"underflow",value:this}),h(this,y,B).call(this,e/o(t,l),"divSignal")}cmp(t){let e=this.value,n=t.value;const s=this.decimals-t.decimals;return s>0?n*=C(s):s<0&&(e*=C(-s)),e<n?-1:e>n?1:0}eq(t){return this.cmp(t)===0}lt(t){return this.cmp(t)<0}lte(t){return this.cmp(t)<=0}gt(t){return this.cmp(t)>0}gte(t){return this.cmp(t)>=0}floor(){let t=o(this,l);return o(this,l)<f&&(t-=o(this,g)-F),t=o(this,l)/o(this,g)*o(this,g),h(this,y,B).call(this,t,"floor")}ceiling(){let t=o(this,l);return o(this,l)>f&&(t+=o(this,g)-F),t=o(this,l)/o(this,g)*o(this,g),h(this,y,B).call(this,t,"ceiling")}round(t){if(t==null&&(t=0),t>=this.decimals)return this;const e=this.decimals-t,n=Ct*C(e-1);let s=this.value+n;const r=C(e);return s=s/r*r,_(s,o(this,w),"round"),new N(k,s,o(this,w))}isZero(){return o(this,l)===f}isNegative(){return o(this,l)<f}toString(){return this._value}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(t){return N.fromString(this.toString(),t)}static fromValue(t,e,n){const s=e==null?0:et(e),r=K(n);let a=Bt(t,"value");const c=s-r.decimals;if(c>0){const u=C(c);D(a%u===f,"value loses precision for format","NUMERIC_FAULT",{operation:"fromValue",fault:"underflow",value:t}),a/=u}else c<0&&(a*=C(-c));return _(a,r,"fromValue"),new N(k,a,r)}static fromString(t,e){const n=t.match(/^(-?)([0-9]*)\.?([0-9]*)$/);S(n&&n[2].length+n[3].length>0,"invalid FixedNumber string value","value",t);const s=K(e);let r=n[2]||"0",a=n[3]||"";for(;a.length<s.decimals;)a+=A;D(a.substring(s.decimals).match(/^0*$/),"too many decimals for format","NUMERIC_FAULT",{operation:"fromString",fault:"underflow",value:t}),a=a.substring(0,s.decimals);const c=BigInt(n[1]+r+a);return _(c,s,"fromString"),new N(k,c,s)}static fromBytes(t,e){let n=q(nt(t,"value"));const s=K(e);return s.signed&&(n=J(n,s.width)),_(n,s,"fromBytes"),new N(k,n,s)}};w=new WeakMap,l=new WeakMap,g=new WeakMap,T=new WeakSet,x=function(t){S(this.format===t.format,"incompatible format; use fixedNumber.toFormat","other",t)},y=new WeakSet,B=function(t,e){return t=_(t,o(this,w),e),new N(k,t,o(this,w))},R=new WeakSet,X=function(t,e){return h(this,T,x).call(this,t),h(this,y,B).call(this,o(this,l)+o(t,l),e)},$=new WeakSet,Y=function(t,e){return h(this,T,x).call(this,t),h(this,y,B).call(this,o(this,l)-o(t,l),e)},P=new WeakSet,V=function(t,e){return h(this,T,x).call(this,t),h(this,y,B).call(this,o(this,l)*o(t,l)/o(this,g),e)},O=new WeakSet,tt=function(t,e){return D(o(t,l)!==f,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),h(this,T,x).call(this,t),h(this,y,B).call(this,o(this,l)*o(this,g)/o(t,l),e)};let z=N;const ut=["wei","kwei","mwei","gwei","szabo","finney","ether"];function ht(i,t){let e=18;if(typeof t=="string"){const n=ut.indexOf(t);S(n>=0,"invalid unit","unit",t),e=3*n}else t!=null&&(e=et(t,"unit"));return z.fromValue(i,e,{decimals:e,width:512}).toString()}function kt(i,t){S(typeof i=="string","value must be a string","value",i);let e=18;if(typeof t=="string"){const n=ut.indexOf(t);S(n>=0,"invalid unit","unit",t),e=3*n}else t!=null&&(e=et(t,"unit"));return z.fromString(i,{decimals:e,width:512}).value}function ct(i){return ht(i,18)}function E(i){return kt(i,18)}function Et(i){const t=j(i);if(t.length>31)throw new Error("bytes32 string must be less than 32 bytes");return Tt(t,32)}function Lt(i){const t=nt(i,"bytes");if(t.length!==32)throw new Error("invalid bytes32 - not 32 bytes long");if(t[31]!==0)throw new Error("invalid bytes32 string - no null terminator");let e=31;for(;t[e-1]===0;)e--;return lt(t.slice(0,e))}class Mt{constructor(t){this.contract=new St(wt,yt,t)}stringToBytes32(t){return Et(t)}bytes32ToString(t){return lt(t).replace(/\0/g,"")}chunkData(t){const e=[];for(let n=0;n<t.length;n+=it)e.push(t.slice(n,n+it));return e}async inscribeInline(t,e){const n=j(t);return await(await this.contract.inscribeInline(n,{value:E(M)})).wait()}async inscribeData(t,e,n="",s,r,a,c){const u=this.stringToBytes32(t),d=this.chunkData(e),m=n?this.stringToBytes32(n):rt;return console.log("inscribeData chunks",d.length),d.length>4?await this.handleInscribeBigData(u,d,m,s,r,a,c):await(await this.contract.inscribeData(u,d,m,{value:E(M)})).wait()}async handleInscribeBigData(t,e,n,s,r,a,c){var G;let u=null,d=0;const m=Math.ceil(e.length/4);try{u=Dt.service({lock:!0,text:r>0?"":`Uploading data to blockchain (${d-a}/${m-a})...Dont't refresh the website!`,background:"rgba(0, 0, 0, 0.6)"});let I=0,L=null;if(r==0){c&&c(d,m);const p=await this.contract.inscribeBigData(t,e.slice(0,4),n,e.length,{value:E(M)});d++,this._setLoadingText(u,d-a,m-a),c&&c(d,m),L=await p.wait(),console.log("handleInscribeBigData receipt",L),I=(G=L.logs.map(v=>{try{return this.contract.interface.parseLog(v)}catch{return null}}).filter(v=>v&&v.name==="Inscribe")[0])==null?void 0:G.args[0],U.markCurInscribingBigDataInscriptionId(I)}else if(d=r,this._setLoadingText(u,d-a,m-a),I=U.GetCurInscribingBigDataInscriptionId(),!I){ot.error("Invalid status, please refresh website");return}console.log(`handleInscribeBigData itemId:${I}, sentTxCount:${r}`);const dt=r>0?r*4:4;for(let p=dt;p<e.length;p+=4){const Q=e.slice(p,Math.min(p+4,e.length)),v=p;console.log(`Appending group ${Math.floor(p/4)}:`,Q.length,"chunks starting at index",v);const gt=await this.contract.appendBigData(I,v,Q);d++,this._setLoadingText(u,d-a,m-a),c&&c(d,m),L=await gt.wait(),console.log(`âœ… Appended group ${Math.floor(p/4)} successfully`)}return console.log("ðŸŽ‰ handleInscribeBigData finish"),L}catch(I){throw console.error(I),I}finally{u&&u.close()}}_setLoadingText(t,e,n){t.setText(`Uploading data to blockchain (Sent ${e}/${n})...Dont't refresh the website!`)}async inscribeBigData(t,e,n,s){const r=n?this.stringToBytes32(n):rt,a=this.stringToBytes32(t);return await(await this.contract.inscribeBigData(a,e,r,s,{value:E(M)})).wait()}async appendBigData(t,e,n){return await(await this.contract.appendBigData(t,e,n)).wait()}async deployToken(t,e,n,s,r,a){if(!await this.checkBalance(a,U.InscribeEstimateGas.kDeployToken,Number(st)))return;const u=this.stringToBytes32(e);return console.log("deployToken",{name:t,symbol:e,decimals:n,mintTimes:s,amountPerMint:r,symbolBytes32:u}),await(await this.contract.deployToken(t,u,BigInt(n),BigInt(s),BigInt(r),{value:E(st)})).wait()}async mintToken(t,e){const n=this.stringToBytes32(t);return await(await this.contract.mintToken(n,{value:E(bt)})).wait()}async checkBalance(t,e,n){if(window.lastCheckBalanceTime&&window.lastBalance&&Date.now()-window.lastCheckBalanceTime<6e4&&window.lastBalance>.03)return console.log("checkBalance simple return"),!0;window.lastCheckBalanceTime=Date.now();const s=await this.contract.runner.provider.getBalance(t),r=parseFloat(ct(s));window.lastBalance=r,console.log(`User: ${t}, balance: ${r} ETH`);const a=await this.contract.runner.provider.send("eth_gasPrice",[]),c=BigInt(a),u=parseFloat(ht(c,"gwei"));console.log("Current gas price:",u,"gwei");const d=e*c,m=parseFloat(ct(d))*1.5+parseFloat(n);return console.log("minEth",m),r<m?(ot.error(`Insufficient balance: need at least ${m.toFixed(4)} ETH, but you have ${r.toFixed(4)} ETH.`),!1):!0}async setTokenURI(t,e){const n=this.stringToBytes32(t);return await(await this.contract.setTokenURI(n,e)).wait()}async getItem(t){const e=await this.contract.getItem(t);return{dataType:this.bytes32ToString(e.dataType),inlineData:e.inlineData,dataHolders:e.dataHolders,userData:this.bytes32ToString(e.userData),contentSize:Number(e.contentSize)}}async findFirstInlines(t){const e=t.map(n=>j(n));return await this.contract.findFirstInlines(e)}async itemIdsByOwnerAndIndexList(t,e){return await this.contract.itemIdsByOwnerAndIndexList(t,e)}async getSymbolList(t,e){return(await this.contract.getSymbolList(t,e)).map(s=>this.bytes32ToString(s))}async getTokenInfoList(t,e){const[n,s,r,a]=await this.contract.getTokenInfoList(t,e);return r.map((c,u)=>({name:s[u],symbol:this.bytes32ToString(n[u]),decimals:c.decimals,token:c.token,totalSupply:BigInt(c.amountPerMint)*BigInt(c.mintTimes),amountPerMint:c.amountPerMint.toString(),mintTimes:Number(c.mintTimes),createAt:Number(c.createAt),itemId:Number(c.itemId),minted:a[u].toString()}))}async getTokenInfoListBySymbols(t){let e=[];for(const a of t)e.push(this.stringToBytes32(a));const[n,s,r]=await this.contract.getTokenInfoListBySymbols(e);return s.map((a,c)=>({name:n[c],symbol:t[c],decimals:a.decimals,token:a.token,totalSupply:BigInt(a.amountPerMint)*BigInt(a.mintTimes),amountPerMint:a.amountPerMint.toString(),mintTimes:Number(a.mintTimes),createAt:Number(a.createAt),itemId:Number(a.itemId),minted:r[c].toString()}))}async getItemList(t,e){return(await this.contract.getItemList(t,e)).map(s=>({dataType:this.bytes32ToString(s.dataType),inlineData:s.inlineData,dataHolders:s.dataHolders,userData:this.bytes32ToString(s.userData),contentSize:Number(s.contentSize)}))}async readAddressCodes(t){return await this.contract.readAddressCodes(t)}async readData(t){return console.log("onchain readData",t),await this.contract.readData(t)}async readDataList(t){return console.log("onchain readDataList",t),await this.contract.readDataList(t)}async getSymbolCounter(){return Number(await this.contract.symbolCounter())}async validateSymbol(t){const e=this.stringToBytes32(t),[n,s]=await this.contract.validateSymbol(e);return{isValid:n,length:Number(s)}}async getItemIdCounter(){return window.lastQueryItemIdCountTime&&Date.now()-window.lastQueryItemIdCountTime<=1e4||(window.lastQueryItemIdCountTime=Date.now(),window.lastQueryItemIdCount=Number(await this.contract.itemIdCounter())),window.lastQueryItemIdCount}async ownerOf(t,e){let n=U.ownerDict[t];return(!n||!e||Date.now()-n.cacheStamp>e*1e3)&&(n={cacheStamp:Date.now(),cacheResult:await this.contract.ownerOf(t)},U.ownerDict[t]=n),n.cacheResult}async balanceOf(t){return Number(await this.contract.balanceOf(t))}async getTokenInfo(t){const e=this.stringToBytes32(t),n=await this.contract.tokenInfoDict(e);return{token:n.token,decimals:n.decimals,amountPerMint:n.amountPerMint.toString(),mintTimes:Number(n.mintTimes),totalSupply:BigInt(n.amountPerMint)*BigInt(n.mintTimes),createAt:Number(n.createAt),itemId:Number(n.itemId)}}async getTokenName(t){const e=this.stringToBytes32(t);return await this.contract.tokenNameDict(e)}async getTokenMinted(t){const e=this.stringToBytes32(t);return Number(await this.contract.tokenMintedDict(e))}async getBigDataChunkCount(t){return Number(await this.contract.bigDataChunkCountDict(t))}async tokenOfOwnerByIndex(t,e){return Number(await this.contract.tokenOfOwnerByIndex(t,e))}async totalSupply(){return Number(await this.contract.totalSupply())}static TryParseIncompleteHolderData(t){if(!t||t.length<=2||t.length>200)return null;const e=nt(t),n=e.slice(11,43),s=e.slice(44,76),r=q(n),a=q(s);return{curChunkCount:r,totalChunkCount:a,desc:`Incomplete chunks: ${r}/${a}`}}static GetInscribeFileFee(){return M}}const _t={kIsMainnet:!1,getProvider:function(){const i=U.GetRPCUrl();return new Nt(i)}};export{_t as C,z as F,Mt as I,ct as a,kt as b,Lt as d,Et as e,ht as f,E as p};
